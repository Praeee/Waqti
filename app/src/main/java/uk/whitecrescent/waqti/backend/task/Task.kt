@file:Suppress("NOTHING_TO_INLINE")

package uk.whitecrescent.waqti.backend.task

import android.annotation.SuppressLint
import io.objectbox.annotation.Convert
import io.objectbox.annotation.Entity
import io.objectbox.annotation.Id
import io.reactivex.Observable
import io.reactivex.Observer
import io.reactivex.disposables.Disposable
import io.reactivex.schedulers.Schedulers
import uk.whitecrescent.waqti.Duration
import uk.whitecrescent.waqti.MissingFeature
import uk.whitecrescent.waqti.NonFinal
import uk.whitecrescent.waqti.TestedDocumentedAndFinalSince
import uk.whitecrescent.waqti.Time
import uk.whitecrescent.waqti.UpdateDocumentation
import uk.whitecrescent.waqti.UpdateTests
import uk.whitecrescent.waqti.WaqtiVersion
import uk.whitecrescent.waqti.backend.Cacheable
import uk.whitecrescent.waqti.backend.persistence.Caches
import uk.whitecrescent.waqti.backend.task.Properties.BEFORE
import uk.whitecrescent.waqti.backend.task.Properties.CHECKLIST
import uk.whitecrescent.waqti.backend.task.Properties.DEADLINE
import uk.whitecrescent.waqti.backend.task.Properties.DESCRIPTION
import uk.whitecrescent.waqti.backend.task.Properties.DURATION
import uk.whitecrescent.waqti.backend.task.Properties.LABELS
import uk.whitecrescent.waqti.backend.task.Properties.PRIORITY
import uk.whitecrescent.waqti.backend.task.Properties.SUB_TASKS
import uk.whitecrescent.waqti.backend.task.Properties.TARGET
import uk.whitecrescent.waqti.backend.task.Properties.TIME
import uk.whitecrescent.waqti.ids
import uk.whitecrescent.waqti.isAfter
import uk.whitecrescent.waqti.isBefore
import uk.whitecrescent.waqti.isInThePast
import uk.whitecrescent.waqti.isNotConstrained
import uk.whitecrescent.waqti.isUnMet
import uk.whitecrescent.waqti.logD
import uk.whitecrescent.waqti.now
import uk.whitecrescent.waqti.tasks
import uk.whitecrescent.waqti.toArrayList

@UpdateTests // tests are old, update them
@UpdateDocumentation // documentation is very old, update it
@NonFinal

@Entity
class Task(name: String = "") : Cacheable {

    //region Class Properties

    /**
     * The name of this Task, should not be set to empty as this is the default which we will use
     * to determine that this Task is not generated by ObjectBox.
     *
     * @see notDefault
     */
    override var name = name
        set(value) {
            field = value
            update()
        }

    /**
     * The [ID] of this Entity as given by ObjectBox
     *
     * @see Cacheable.id
     */
    @Id
    override var id = 0L

    /**
     * The [TaskState] is the state in which the task is in at this point in time.
     * By default this is initialized to [TaskState.EXISTING], see [DEFAULT_TASK_STATE].
     *
     * The Task State changes according to Lifecycle changes made by [sleep], [kill] or [fail],
     * such changes can also occur due to constrained Properties, see [backgroundObserver].
     *
     * @see TaskState
     * @see DEFAULT_TASK_STATE
     */
    @Convert(converter = TaskStateConverter::class, dbType = String::class)
    var state = DEFAULT_TASK_STATE
        private set(value) {
            field = value
            update()
        }

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     *
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     *
     * @see TaskState
     */
    var isFailable = DEFAULT_FAILABLE
        set(value) {
            field = value
            update()
        }

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     *
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     *
     * @see TaskState
     */
    var isKillable = DEFAULT_KILLABLE
        set(value) {
            field = value
            update()
        }

    @MissingFeature
    // TODO: 02-Feb-19 we haven't properly used this, should we keep it?
    // The times a task has been failed
    @Convert(converter = TimeArrayListConverter::class, dbType = String::class)
    val failedTimes = TimeArrayList()

    // The time a task is killed
    @Convert(converter = TimeConverter::class, dbType = String::class)
    var killedTime = DEFAULT_TIME
        private set

    // Used for Duration Constraint
    @Transient
    private val timer = Timer()

    /**
     * Used to determine the overall state of this Task at this point in time.
     *
     * This is especially useful for [Task.hashCode] and [Task.equals] hence the implementation does not contain as
     * many aspects of this Task as it could.
     *
     * A Task's Equality Bundle is determined by the following:
     *
     * * [name]
     * * [state]
     * * [isFailable]
     * * [isKillable]
     * * [failedTimes]
     * * [killedTime]
     * * [allProperties], the list of this Task's Properties.
     *
     * For [allProperties] see [java.util.ArrayList.equals], essentially all Properties must be equal in order for
     * this to be satisfied see [Property.equals] meaning even the values must be equal, this will differ depending
     * on the type of value, for example any [Time] is equal to another if and only if they are exactly the
     * same to the nanosecond precision see [Time.equals] whereas [StringBuilder] checks for equality using
     * identity meaning two different StringBuilder instances can have the exact same value and be consider unequal
     * see [java.lang.StringBuilder] (it does not override equals, hence this default implementation)
     *
     * @see HashMap
     * @return a HashMap with `String` as the Key and `Any` as the Value to represent the Equality Bundle which will
     * store the parts that make up a Task's overall state
     */
    private inline val equalityBundle: HashMap<String, Any>
        get() {
            val bundle = HashMap<String, Any>(8)
            bundle["name"] = this.name
            bundle["state"] = this.state
            bundle["isFailable"] = this.isFailable
            bundle["isKillable"] = this.isKillable
            bundle["failedTimes"] = this.failedTimes
            bundle["killedTime"] = this.killedTime
            bundle["properties"] = this.allProperties
            return bundle
        }

    /**
     * Map showing which properties we are currently observing, represented by a string being the
     * name of the property to the boolean whether it is being observed or not.
     */
    @Transient
    private val observingProperties = mutableMapOf(
            TIME to false,
            DURATION to false,
            CHECKLIST to false,
            DEADLINE to false,
            BEFORE to false,
            SUB_TASKS to false
    )

    //endregion Class Properties

    //region Task Properties

    /**
     * The point in natural time after which this Task will be relevant, this can also be referred to as scheduled
     * time.
     *
     * If time is constrained then the Task is in the SLEEPING state during that period and
     * cannot be killed until after that time, however, if time is not constrained then
     * the Task can be killed freely and will be in its same state meaning no lifecycle
     * changes will be made.
     *
     * @see Time
     * @documented 03-Feb-19
     */
    @TestedDocumentedAndFinalSince(WaqtiVersion.FEB_2019)
    @Convert(converter = TimePropertyConverter::class, dbType = String::class)
    var time: TimeProperty = DEFAULT_TIME_PROPERTY
        private set

    /**
     * The estimated amount of time that this Task will take, this can also be referred to as minimum duration.
     *
     * This is defined in any Time Measurement Unit, either as a standard Time Unit such as seconds or days etc or
     * custom Time Units [TimeUnit]. If duration is constrained then the Task cannot be killed in
     * the midst of the duration, it can be killed only after it has ended.
     *
     * The Duration is started by a [timer], you must start this timer in order for the Duration
     * to start decreasing, currently this is the only Property that requires and additional step
     * to be done before observing is started in [observeDuration] which is only called in
     * [startTimer]. The duration property does not decrease, rather the duration left in the
     * timer does which can be queried using [timerDuration].
     *
     * @see Duration
     * @see TimeUnit
     * @see Timer
     */
    @TestedDocumentedAndFinalSince(WaqtiVersion.FEB_2019)
    @Convert(converter = DurationPropertyConverter::class, dbType = String::class)
    var duration: DurationProperty = DEFAULT_DURATION_PROPERTY
        private set

    /**
     * The user defined level of importance of a Task represented as a String with a number representing importance
     * level.
     *
     * Priority is particularly useful in solving or mediating Task collisions within collections. A Task collision
     * occurs when two or more Tasks in a collection share the same time, if they have different priority levels then
     * the Task with the higher priority level will be shown and a collision warning will be displayed to the user,
     * this is called a weak collision. If the tasks have equal priority levels then the user must mediate or solve
     * the collision themselves, this is called a strong collision.
     *
     * Priority can not be a Constraint.
     *
     * @see Priority
     */
    @Convert(converter = PriorityPropertyConverter::class, dbType = String::class)
    var priority: PriorityProperty = DEFAULT_PRIORITY_PROPERTY
        private set

    /**
     * The user defined category(s) that this Task belongs to.
     *
     * A Task can belong to or have 0 or many labels. Labels are used as a way of categorizing Tasks and are thus
     * helpful in filtering and analytics.
     *
     * Labels can not be a Constraint.
     *
     * @see ArrayList
     * @see Label
     */
    @Convert(converter = LabelArrayListPropertyConverter::class, dbType = String::class)
    var labels: LabelArrayListProperty = DEFAULT_LABELS_PROPERTY
        private set

    /**
     * Shows whether the Task is optional or not.
     *
     * An optional Task is one that is to be done or pursued if there is free time, thus an optional Task has less
     * priority than a non-optional Task (mandatory Task) even if the Task has the lowest priority, this makes
     * optional Tasks the lowest priority of all Tasks. In many ways the optional Property acts similar to the priority
     * Property except in that optional is lower priority than the lowest priority.
     *
     * Optional can not be a Constraint.
     *
     * @see Boolean
     */
    @Convert(converter = BooleanPropertyConverter::class, dbType = String::class)
    var optional: BooleanProperty = DEFAULT_OPTIONAL_PROPERTY
        private set

    /**
     * A textual description of this Task, useful for if the Task is complex or requires further information that the
     * name cannot provide.
     *
     * Description can not be a Constraint.
     *
     * @see StringBuilder
     */
    @Convert(converter = StringPropertyConverter::class, dbType = String::class)
    var description: StringProperty = DEFAULT_DESCRIPTION_PROPERTY
        private set

    /**
     * A list of checkable items that this Task may have.
     *
     * This is useful if the Task can be broken down into smaller chunks which can be represented as list items in a
     * checklist. Items in a checklist can be checked or deleted.
     *
     * If a checklist is a Constraint then the Task cannot be killed unless every item in the checklist is checked,
     * more specifically the checklist has no unchecked items. An empty checklist has no unchecked items so it is
     * important that the implementation be aware of this and differentiate between an empty checklist (which is
     * possible for good reasons) and a checklist with all its items checked.
     *
     * If checklist is a Property then it has no rules on killing the Task.
     *
     * @see Checklist
     * @see ListItem
     */
    @Convert(converter = ChecklistPropertyConverter::class, dbType = String::class)
    var checklist: ChecklistProperty = DEFAULT_CHECKLIST_PROPERTY
        private set

    /**
     * The point in natural time after which this Task can no longer be killed and thus is FAILED.
     *
     * If deadline is a Constraint then after the deadline time passes plus the grace period [GRACE_PERIOD] the Task will be
     * FAILED and thus no longer can be KILLED.
     *
     * If deadline is a Property it has no rules on failing or killing the Task.
     *
     * @see Time
     * @see GRACE_PERIOD
     */
    @Convert(converter = TimePropertyConverter::class, dbType = String::class)
    var deadline: TimeProperty = DEFAULT_DEADLINE_PROPERTY
        private set

    /**
     * The user defined textual representation of a desirable target to be achieved by the user before killing this
     * Task.
     *
     * If target is a Constraint then the Task cannot be killed unless the Target is checked. If target is a Property
     * then it has no rules on killing the Task and acts very similar to a description.
     *
     * @see String
     */
    @Convert(converter = StringPropertyConverter::class, dbType = String::class)
    var target: StringProperty = DEFAULT_TARGET_PROPERTY
        private set

    /**
     * The Task that occurs before this Task.
     *
     * If before is a Constraint then this Task cannot be killed unless the before Task is killed, and if the before
     * Task is FAILED then this Task will also be FAILED if it can be since this Task will have a dependence on the
     * state of the before Task.
     *
     * If before is a Property then it has no rules on killing or failing the Task, it will just be a description of
     * the Task that comes before this one, good for ordering Tasks but not enforcing any ordering of completion.
     *
     * @see Long
     */
    @Convert(converter = LongPropertyConverter::class, dbType = String::class)
    var before: LongProperty = DEFAULT_BEFORE_PROPERTY
        private set

    /**
     * The list of sub-Tasks this Task has, a Task can have zero to potentially many sub-Tasks but has zero by
     * default.
     *
     * If SubTasks is a Constraint then the state of the sub-Tasks is shared upwards to the parent, meaning
     * if this Task's sub-Tasks contains a FAILED Task then this Task is FAILED, if this Task's sub-Tasks contains a
     * non-killed non-optional Task then this Task cannot be killed, only if all the sub-Tasks are KILLED will the
     * Constraint be met.
     *
     * If SubTasks is a Property then it has no rules on killing or failing the Task, the sub-Tasks' states will make
     * no difference to this Task.
     *
     * @see ArrayList
     * @see Long
     */
    @Convert(converter = LongArrayListPropertyConverter::class, dbType = String::class)
    var subTasks: LongArrayListProperty = DEFAULT_SUB_TASKS_PROPERTY
        private set

    init {
        if (notDefault()) {
            update()
            initialize()
        }
    }

    //endregion Task Properties

    //region Task Properties Functions

    /**
     * Gets the list of all the Properties of a Task, does not matter what their values are.
     * See the Properties.md docs for more.
     * @return the list of all the Properties of a Task.
     */
    val allProperties
        get() = listOf(
                time,
                duration,
                priority,
                labels,
                optional,
                description,
                checklist,
                deadline,
                target,
                before,
                subTasks
        )

    /**
     * Gets the list of all Constraints of this Task, does not matter what their values are as long as they are
     * Constraints.
     * @return the list of all current Constraints of this Task
     */
    val allConstraints
        get() = allProperties.filter { it.isConstrained }

    /**
     * Gets the list of all Properties of this Task that are showing. These would usually be the Properties of
     * interest.
     * @see Property
     * @return the list of all showing Properties this Task has
     */
    val allShowingProperties
        get() = allProperties.filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing. The `isMet` value of the Constraints is ignored.
     * @return the list of all showing Constraints this Task has
     */
    val allShowingConstraints
        get() = allConstraints.filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing and also unmet. These would usually be the
     * Constraints of interest and the Constraints that would prevent a Task from being killed.
     * A Task can only be killed if this list is empty.
     * @see canKill
     * @see kill
     * @return the list of all showing and unmet Constraints this Task has
     */
    val allUnmetAndShowingConstraints
        get() = allConstraints.filter { !it.isMet && it.isVisible }

    fun unConstrainAll(): Task {
        allConstraints.forEach {
            it.isConstrained = false
            it.isMet = false
        }
        return this
    }

    /**
     * Makes this Task failable if the passed in Property is a Constraint and this Task is not currently failable.
     * @see Property
     * @see isFailable
     * @param property the Property to check for if it is a Constraint
     */
    private inline fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property.isConstrained) {
            this.isFailable = true
        }
    }

    private inline fun makeNonFailableIfNoConstraints() {
        if (this.allConstraints.isEmpty()) this.isFailable = false
    }

    //endregion Task Properties Functions

    //region Property setters for chaining

    fun changeName(newName: String): Task {
        this.name = newName
        return this
    }

    //region Time

    /**
     * Sets this Task's time Property.
     *
     * In the case that the passed in `timeProperty` is constrained and it is after now, three
     * things will happen:
     *
     * * This Task's state will become SLEEPING
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time, and will become EXISTING once the time in `timeProperty` has passed
     * and will also make the time Constraint MET if it wasn't already, see [observeTime]
     *
     * If the passed in `timeProperty` is not constrained or is not after now then the Task's
     * state will remain the same.
     *
     * @see observeTime
     * @param timeProperty the `Property` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeProperty(timeProperty: Property<Time>): Task {
        this.time = TimeProperty(
                timeProperty.isVisible, timeProperty.value, timeProperty.isConstrained, timeProperty.isMet)

        if (this.time.isConstrained) {
            if (this.time.value isAfter now) {
                if (canSleep()) sleep()
                makeFailableIfConstraint(this.time)
            }

            if (this.time.value isBefore now) {
                this.time.isMet = MET
            }
            observingProperties[TIME] = true
        }
        update()
        return this
    }

    /**
     * Sets this Task's time Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing
     * `setTimeProperty(Property(SHOWING, myTime, NOT_CONSTRAINED, UNMET))`
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimePropertyValue(time: Time) = setTimeProperty(Property(SHOWING, time, NOT_CONSTRAINED, UNMET))

    /**
     * Sets this Task's time Property with the given value and makes the Property showing,
     * constrained and unmet.
     *
     * This is a shorthand of writing
     * `setTimeProperty(Property(SHOWING, myTime, CONSTRAINED, UNMET))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeConstraintValue(time: Time) = setTimeProperty(Property(SHOWING, time, CONSTRAINED, UNMET))

    //endregion Time

    //region Duration

    /**
     * Sets this Task's duration Property, the passed in Property can be constrained.
     *
     * Further changes will occur only if the passed in `durationProperty` is constrained.
     *
     * In the case that the passed in `durationProperty` is constrained, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will be ready to start observing the duration passed since the timer has been
     * started, but this must be done manually, the timer MUST be started for observing to
     * actually start and is thus not done here, rather it is done in [startTimer]
     *
     * @see startTimer
     * @see observeDuration
     * @see Timer
     * @see timer
     * @param durationProperty the [Property] of type [Duration] that this Task's duration will
     * be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = DurationProperty(
                durationProperty.isVisible, durationProperty.value,
                durationProperty.isConstrained, durationProperty.isMet
        )
        if (durationProperty.isConstrained) {
            makeFailableIfConstraint(durationProperty)
        }
        update()
        return this
    }

    /**
     * Gets this Task's duration left until the set duration will be over or basically the
     * difference in time between now and the time the duration is due to finish
     *
     * @return the Duration left until this Task's duration Constraint is met
     * @throws TaskException if the Duration has not been set or is hidden meaning equal to
     * [DEFAULT_DURATION_PROPERTY]
     */
    val durationLeft: Duration
        get() = (if (duration == DEFAULT_DURATION_PROPERTY) throw TaskException("Duration not set!")
        else duration.value - timer.duration)

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing
     * `setDurationProperty(Property(SHOWING, myDuration, NOT_CONSTRAINED, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the [Duration] value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyValue(duration: Duration) =
            setDurationProperty(Property(SHOWING, duration, NOT_CONSTRAINED, UNMET))

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing,
     * constrained and unmet.
     *
     * This is a shorthand of writing
     * `setDurationProperty(Property(SHOWING, myDuration, CONSTRAINED, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the [Duration] value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationConstraintValue(duration: Duration) =
            setDurationProperty(Property(SHOWING, duration, CONSTRAINED, UNMET))

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value
     *
     * This allows to use Custom Time Units for setting the duration Property
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitProperty the Property of type `TimeUnit` that will be used to set this Task's duration
     * Property's value by multiplying by the `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnits(timeUnitProperty: Property<TimeUnit>, count: Int) =
            setDurationProperty(
                    Property(isVisible = timeUnitProperty.isVisible,
                            value = timeUnitProperty.value * count,
                            isConstrained = timeUnitProperty.isConstrained,
                            isMet = timeUnitProperty.isMet)
            )

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and makes the Property showing.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationPropertyTimeUnits(Property(SHOWING, myTimeUnit, NOT_CONSTRAINED, UNMET),myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnitsValue(timeUnit: TimeUnit, count: Int) =
            setDurationPropertyValue(timeUnit * count)

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the
     * `count` as the Property's value and makes the Property showing, constrained and unmet.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationConstraintTimeUnits(Property(SHOWING, myTimeUnit, CONSTRAINED UNMET), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnitsValue(timeUnit: TimeUnit, count: Int) =
            setDurationConstraintValue(timeUnit * count)

    //endregion Duration

    //region Priority

    /**
     * Sets this Task's priority Property.
     *
     * Priority is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for priority.
     *
     * @see Priority
     * @param priorityProperty the `Property` of type `Priority` that this Task's priority will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = PriorityProperty(
                priorityProperty.isVisible, priorityProperty.value, false, false)
        update()
        return this
    }

    /**
     * Sets this Task's priority Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setPriorityProperty(Property(SHOWING, myPriority))`.
     *
     * @see Task.setPriorityProperty
     * @param priority the Priority value that this Task's priority value will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityValue(priority: Priority) =
            setPriorityProperty(
                    Property(SHOWING, priority, false, UNMET))

    //endregion Priority

    //region Labels

    /**
     * Sets this Task's labels Property.
     *
     * Label is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for labels.
     *
     * @see Label
     * @param labelProperty the `Property` containing the list of all labels that this Task's labels property will be
     * set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsProperty(labelProperty: Property<ArrayList<Label>>): Task {
        this.labels = LabelArrayListProperty(
                labelProperty.isVisible, labelProperty.value, false, UNMET)
        update()
        return this
    }

    /**
     * Sets this Task's labels Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setLabelsProperty(Property(SHOWING, myLabelList))`.
     *
     * @see Task.setLabelsProperty
     * @param labels the list of labels that this Task's labels Property will be set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsValue(vararg labels: Label) =
            setLabelsValue(labels.asList())

    fun setLabelsValue(labels: Collection<Label>) =
            setLabelsProperty(Property(SHOWING, labels.toArrayList, false, UNMET))

    /**
     * Adds the passed in labels to this Task's labels Property and makes this Task's labels Property showing if it
     * wasn't already.
     *
     * @see Label
     * @param labels the labels to add to this Task's labels Property
     * @return this Task after adding the labels to the Task's labels Property
     */
    fun addLabels(vararg labels: Label): Task {
        if (!this.labels.isVisible) {
            this.labels.isVisible = SHOWING
        }
        this.labels.value.addAll(labels)
        update()
        return this
    }

    /**
     * Removes a label from this Task's labels Property.
     *
     * @see Label
     * @param label the label to remove from this Task's labels Property
     * @return this Task after removing the label from the Task's labels Property
     */
    fun removeLabel(label: Label): Task {
        this.labels.value.remove(label)
        update()
        return this
    }

    //endregion Labels

    //region Optional

    /**
     * Sets this Task's optional Property.
     *
     * Optional is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for optional.
     *
     * @param optionalProperty the `Property` of type `Optional` that this Task's optional will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalProperty(optionalProperty: Property<Optional>): Task {
        this.optional = BooleanProperty(
                optionalProperty.isVisible, optionalProperty.value, false, UNMET)
        update()
        return this
    }

    /**
     * Sets this Task's optional Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setOptionalProperty(Property(SHOWING, myOptional))`.
     *
     * @see Task.setOptionalProperty
     * @param optional the Optional value that this Task's optional value will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalValue(optional: Optional) =
            setOptionalProperty(Property(SHOWING, optional, false, UNMET))

    //endregion Optional

    //region Description

    /**
     * Sets this Task's description Property.
     *
     * Description is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for description.
     *
     * @see StringBuilder
     * @param descriptionProperty the `Property` containing the description that this Task's description property
     * will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionProperty(descriptionProperty: Property<Description>): Task {
        this.description = StringProperty(
                descriptionProperty.isVisible, descriptionProperty.value, false, UNMET)
        update()
        return this
    }

    /**
     * Sets this Task's description Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDescriptionProperty(Property(SHOWING, myDescription))`.
     *
     * @see Task.setDescriptionProperty
     * @param description the description that this Task's description Property will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionValue(description: Description) =
            setDescriptionProperty(Property(SHOWING, description, false, UNMET))

    //endregion Description

    //region Checklist

    /**
     * Sets this Task's checklist Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `checklistProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `checklistProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start viewing the checklist to see if all its list items are checked, if they are, the checklist
     * Constraint is met, see [checklistConstraintChecking]
     *
     * Note: An empty checklist means every item in the checklist is checked so this can make the checklist
     * Constraint met
     *
     * If the passed in `checklistProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.checklistConstraintChecking
     * @see Checklist
     * @param checklistProperty the `Property` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = ChecklistProperty(
                checklistProperty.isVisible, checklistProperty.value,
                checklistProperty.isConstrained, checklistProperty.isMet
        )
        if (checklistProperty.isConstrained) {
            makeFailableIfConstraint(checklistProperty)
            observingProperties[CHECKLIST] = true
        }
        update()
        return this
    }

    /**
     * Sets this Task's checklist Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setChecklistProperty(Property(SHOWING, myChecklist))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistPropertyValue(checklist: Checklist) =
            setChecklistProperty(Property(SHOWING, checklist, false, UNMET))

    /**
     * Sets this Task's checklist Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setChecklistConstraint(Constraint(SHOWING, myChecklist, UNMET))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraintValue(checklist: Checklist) =
            setChecklistProperty(Property(SHOWING, checklist, true, UNMET))

    //endregion Checklist

    //region Deadline

    /**
     * Sets this Task's deadline Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `deadlineProperty` is a Constraint.
     *
     * In the case that the passed in `deadlineProperty` is a Constraint, three things will happen:
     *
     * * The deadline Constraint will become met until that deadline time where it will become unmet again, this is
     * only in the case that the Task is not killed before the deadline, this is done in order to allow the Task to
     * be killed
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time to compare it with the deadline, if the current time is after the
     * deadline plus the defined grace period [GRACE_PERIOD] then the Task becomes failed and the deadline Constraint
     * becomes unmet. See [deadlineConstraintChecking].
     *
     * If the passed in `deadlineProperty` is not a Constraint then there will be no further changes and the Task
     * will not fail automatically.
     *
     * @see Task.deadlineConstraintChecking
     * @param deadlineProperty the `Property` of type `java.time.Time` that this Task's deadline will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlineProperty(deadlineProperty: Property<Time>): Task {
        this.deadline = TimeProperty(
                deadlineProperty.isVisible, deadlineProperty.value,
                deadlineProperty.isConstrained, deadlineProperty.isMet
        )
        if (deadlineProperty.isConstrained) {
            makeFailableIfConstraint(deadlineProperty)
            observingProperties[DEADLINE] = true
        }
        update()
        return this
    }

    /**
     * Gets the duration left until this Task's deadline will occur, this ignores the grace period.
     *
     * @return the Duration left until this Task's deadline occurs, ignores the grace period
     * @throws TaskException if the deadline has not been set
     */
    fun getTimeUntilDeadline(): Duration {
        if (deadline.value == DEFAULT_DEADLINE) {
            throw TaskException("Deadline not set!")
        } else {
            return Duration.between(now, this.deadline.value)
        }
    }

    /**
     * Sets this Task's deadline Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDeadlineProperty(Property(SHOWING, myDeadline))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.Time value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlinePropertyValue(deadline: Time) =
            setDeadlineProperty(Property(SHOWING, deadline, false, UNMET))

    /**
     * Sets this Task's deadline Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDeadlineConstraint(Constraint(SHOWING, myDeadline, UNMET))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.Time value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraintValue(deadline: Time) =
            setDeadlineProperty(Property(SHOWING, deadline, true, UNMET))

    //endregion Deadline

    //region Target

    /**
     * Sets this Task's target Property, the passed in Property can be a Constraint.
     *
     * If the passed in `targetProperty` is a Constraint then this Task will become failable if it wasn't already.
     *
     * @see Target
     * @param targetProperty the `Property` of type `Target` that this Task's target will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetProperty(targetProperty: Property<Target>): Task {
        this.target = StringProperty(
                targetProperty.isVisible, targetProperty.value,
                targetProperty.isConstrained, targetProperty.isMet
        )
        makeFailableIfConstraint(targetProperty)
        update()
        return this
    }

    /**
     * Sets this Task's target Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTargetProperty(Property(SHOWING, myTarget))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's target value will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetPropertyValue(target: Target) =
            setTargetProperty(Property(SHOWING, target, false, UNMET))

    /**
     * Sets this Task's target Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTargetConstraint(Constraint(SHOWING, myTarget, UNMET))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setTargetConstraintValue(target: Target) =
            setTargetProperty(Property(SHOWING, target, CONSTRAINED, UNMET))

    //endregion Target

    //region Before

    /**
     * Sets this Task's before Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `beforeProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `beforeProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of task the before value refers to using the database, and will make
     * the before Constraint met only when the before Task is killed, see [beforeConstraintChecking]
     *
     * If the passed in `beforeProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.beforeConstraintChecking
     * @param beforeProperty the `Property` of type `uk.whitecrescent.waqti.model.task.ID` that this Task's before property will be set to, this is
     * the before Task's uk.whitecrescent.waqti.model.task.ID
     * @return this Task after setting the Task's before Property
     */
    fun setBeforeProperty(beforeProperty: Property<ID>): Task {
        this.before = LongProperty(
                beforeProperty.isVisible, beforeProperty.value,
                beforeProperty.isConstrained, beforeProperty.isMet
        )
        if (beforeProperty.isConstrained) {
            makeFailableIfConstraint(beforeProperty)
            observingProperties[BEFORE] = true
        }
        update()
        return this
    }

    /**
     * Sets this Task's before Property with the given uk.whitecrescent.waqti.model.task.ID value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeID the ID of the Task that is before this one that this Task's before value
     * will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeID: ID) =
            setBeforeProperty(Property(SHOWING, beforeID, false, UNMET))

    /**
     * Sets this Task's before Constraint with the given uk.whitecrescent.waqti.model.task.ID value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeuk.whitecrescent.waqti.task.ID the uk.whitecrescent.waqti.model.task.ID of the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeID: ID) =
            setBeforeProperty(Property(SHOWING, beforeID, true, UNMET))

    /**
     * Sets this Task's before Property with the given Task value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeTask: Task) =
            setBeforeProperty(Property(SHOWING, beforeTask.id, false, UNMET))

    /**
     * Sets this Task's before Constraint with the given Task value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeTask: Task) =
            setBeforeProperty(Property(SHOWING, beforeTask.id, true, UNMET))

    //endregion Before

    //region SubTasks

    /**
     * Sets this Task's sub-Tasks Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `subTasksProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `subTasksProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of all of its sub-Tasks, if all are KILLED then the sub-Tasks
     * Constraint is met, if any one sub-Task is FAILED then this Task is FAILED if it is failable, see [subTasksConstraintChecking]
     *
     * If the passed in `subTasksProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.subTasksConstraintChecking
     * @param subTasksProperty the `Property` of type `ArrayList<uk.whitecrescent.waqti.model.task.ID>` that this Task's subTasks property will be
     * set to, this is the list of uk.whitecrescent.waqti.task.IDs of the sub-Tasks
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksProperty(subTasksProperty: Property<ArrayList<ID>>): Task {
        this.subTasks = LongArrayListProperty(
                subTasksProperty.isVisible, subTasksProperty.value,
                subTasksProperty.isConstrained, subTasksProperty.isMet
        )
        if (subTasksProperty.isConstrained) {
            makeFailableIfConstraint(subTasksProperty)
            observingProperties[SUB_TASKS] = true
        }
        update()
        return this
    }

    /**
     * Sets this Task's subTasks Property with the given ArrayList of uk.whitecrescent.waqti.task.IDs and makes the Property showing.
     *
     * This is a shorthand of writing `setSubTasksProperty(Property(SHOWING, mySubTasks))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks the ArrayList of uk.whitecrescent.waqti.task.IDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksPropertyValue(subTasks: Collection<ID>) =
            setSubTasksProperty(Property(SHOWING, subTasks.toArrayList, false, UNMET))

    /**
     * Sets this Task's subTasks Constraint with the given ArrayList of uk.whitecrescent.waqti.task.IDs and makes the Constraint showing and
     * unmet.
     *
     * This is a shorthand of writing `setSubTasksConstraint(Constraint(SHOWING, mySubTasks, UNMET))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks he ArrayList of uk.whitecrescent.waqti.task.IDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Constraint
     */
    fun setSubTasksConstraintValue(subTasks: Collection<ID>) =
            setSubTasksProperty(Property(SHOWING, subTasks.toArrayList, true, UNMET))

    /**
     * Adds the given subTasks to this Task's subTasks Property and makes this Task's subTasks Property showing if it
     * wasn't already.
     *
     * @param tasks the Tasks to add to this Task's subTasks Property
     * @return this Task after adding the given subTasks to the Task's subTasks Property
     */
    fun addSubTasks(tasks: Collection<Task>): Task {
        if (tasks.isNotEmpty()) {
            this.subTasks.value.addAll(tasks.ids)
            if (!subTasks.isVisible) {
                subTasks.isVisible = true
            }
        }
        return this
    }

    /**
     * Gets the ArrayList of uk.whitecrescent.waqti.task.IDs of the sub-Tasks of this Task
     *
     * @return the ArrayList of uk.whitecrescent.waqti.task.IDs of the sub-Tasks of this Task
     */
    fun getSubTasksIDsList(): List<ID> {
        return this.subTasks.value.toList()
    }

    /**
     * Gets the ArrayList of Tasks of the sub-Tasks of this Task
     *
     * @return the ArrayList of Tasks of the sub-Tasks of this Task
     */
    fun getSubTasksList(): List<Task> {
        return this.subTasks.value.tasks.toList()
    }

    /**
     * Gets the maximum depth of sub-Tasks of this Task, this is a recursive function
     *
     * @return the maximum depth of sub-Tasks of this Task
     */
    fun getSubTasksLevelsDepth(task: Task = this): Int {
        val list = arrayListOf<Int>()
        return if (task.subTasks.value.isEmpty()) {
            0
        } else {
            for (task0 in task.subTasks.value.tasks) {
                list.add(getSubTasksLevelsDepth(task0) + 1)
            }
            list.max()!!
        }
    }

    //endregion SubTasks

    //endregion Property setters for chaining

    //region Hide Properties

    /**
     * Re-sets the Time Property to the default Time Property value [DEFAULT_TIME_PROPERTY] if
     * and only if either:
     * * Time is not constrained, [Property.isConstrained] is false
     * * Time is constrained but also met, [Property.isConstrained] is true AND
     * [Property.isMet] is true
     *
     * @see Property
     * @throws CannotHidePropertyException if the above conditions are not met
     */
    fun hideTime() {
        if (time.isNotConstrained || (time.isConstrained && time.isMet)) {
            time = DEFAULT_TIME_PROPERTY
            update()
        } else throw CannotHidePropertyException("Cannot hide, time is an unmet Constraint: $time")
    }

    /**
     * Re-sets the Duration Property to the default Duration Property value
     * [DEFAULT_DURATION_PROPERTY] if and only if either:
     * * Duration id not constrained, [Property.isConstrained] is false
     * * Duration is constrained but also met, [Property.isConstrained] is true AND
     * [Property.isMet] is true
     *
     * @see Property
     * @throws CannotHidePropertyException if the above conditions are not met
     */
    fun hideDuration() {
        if (duration.isNotConstrained || (duration.isConstrained && duration.isMet)) {
            duration = DEFAULT_DURATION_PROPERTY
            update()
        } else throw CannotHidePropertyException("Cannot hide, duration is an unmet Constraint: $duration")
    }

    fun hidePriority() {
        if (!priority.isConstrained) {
            priority = DEFAULT_PRIORITY_PROPERTY
            update()
        } else throw TaskException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (!labels.isConstrained) {
            labels = DEFAULT_LABELS_PROPERTY
            update()
        } else throw TaskException("Cannot hide, labels is Constraint")
    }

    fun hideOptional() {
        if (!optional.isConstrained) {
            optional = DEFAULT_OPTIONAL_PROPERTY
            update()
        } else throw TaskException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (!description.isConstrained) {
            description = DEFAULT_DESCRIPTION_PROPERTY
            update()
        } else throw TaskException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (!checklist.isConstrained) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
            update()
        } else throw TaskException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (!deadline.isConstrained) {
            deadline = DEFAULT_DEADLINE_PROPERTY
            update()
        } else throw TaskException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (!target.isConstrained) {
            target = DEFAULT_TARGET_PROPERTY
            update()
        } else throw TaskException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (!before.isConstrained) {
            before = DEFAULT_BEFORE_PROPERTY
            update()
        } else throw TaskException("Cannot hide, before is Constraint")
    }

    fun hideSubTasks() {
        if (!subTasks.isConstrained) {
            subTasks = DEFAULT_SUB_TASKS_PROPERTY
            update()
        } else throw TaskException("Cannot hide, subTasks is Constraint")
    }

    //endregion Hide Properties

    //region UnConstrain Properties

    fun unConstrain(property: Properties): Task {
        when (property) {
            TIME -> setTimeProperty(this.time.unConstrain())
            DURATION -> setDurationProperty(this.duration.unConstrain())
            PRIORITY -> setPriorityProperty(this.priority.unConstrain())
            LABELS -> setLabelsProperty(this.labels.unConstrain())
            Properties.OPTIONAL -> setOptionalProperty(this.optional.unConstrain())
            DESCRIPTION -> setDescriptionProperty(this.description.unConstrain())
            CHECKLIST -> setChecklistProperty(this.checklist.unConstrain())
            TARGET -> setTargetProperty(this.target.unConstrain())
            DEADLINE -> setDeadlineProperty(this.deadline.unConstrain())
            BEFORE -> setBeforeProperty(this.before.unConstrain())
            SUB_TASKS -> setSubTasksProperty(this.subTasks.unConstrain())
        }
        return this
    }

    //endregion UnConstrain Properties

    //region Task lifecycle

    override fun update() {
        Caches.tasks.put(this)
    }

    fun canKill() = isKillable &&
            this.state == TaskState.EXISTING &&
            allUnmetAndShowingConstraints.isEmpty()

    fun canFail() = isFailable &&
            this.state == TaskState.EXISTING

    fun canSleep() = this.state == TaskState.FAILED ||
            this.state == TaskState.EXISTING

    fun fail() {
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.name} is not Failable", this.state)
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.name} is already Failed!", this.state)
        }
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Fail unsuccessful, ${this.name} is Sleeping!", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Fail unsuccessful, ${this.name} is Killed!", this.state)
        } else if (canFail()) {
            state = TaskState.FAILED
            failedTimes.add(now)
            update()
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be " +
                    "failed!", this.state)
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.name} is already Sleeping!", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.name} is Killed!", this.state)
        } else if (canSleep()) {
            state = TaskState.SLEEPING
            update()
        } else {
            throw TaskStateException(
                    "Sleep unsuccessful, unknown reason, remember only FAILED or EXISTING tasks can be Slept!",
                    this.state)
        }
    }

    fun kill() {
        // TODO: 04-Feb-19 Should we block killed Tasks from having any of their Properties changed?
        // definitely we should block any observing but even block Property changes??
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.name} is not Killable", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.name} is already Killed!", this.state)
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Kill unsuccessful, ${this.name} is Failed", this.state)
        }
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Kill unsuccessful, ${this.name} is Sleeping", this.state)
        }
        if (allUnmetAndShowingConstraints.isNotEmpty()) {
            throw TaskStateException(
                    "Kill unsuccessful, ${this.name} has unmet Constraints ${this.allUnmetAndShowingConstraints}",
                    this.state)
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now
            update()
        } else {
            throw TaskStateException(
                    "Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!",
                    this.state)
        }
    }

    //endregion Task lifecycle

    //region Timer

    // Timer is independent of Duration Constraint, but Duration Constraint needs the timer to run to be MET

    fun startTimer(): Task {
        if (state != TaskState.EXISTING) {
            throw TaskStateException("Task must be EXISTING to start Timer!", state)
        } else {
            timer.start()
            if (duration.isConstrained) {
                observingProperties[DURATION] = true
            }
        }
        return this
    }

    fun pauseTimer(): Task {
        timer.pause()
        return this
    }

    fun stopTimer(): Task {
        timer.stop()
        return this
    }

    val timerDuration: Duration get() = timer.duration

    val timerIsRunning: Boolean get() = timer.running

    val timerIsPaused: Boolean get() = timer.paused

    val timerIsStopped: Boolean get() = timer.stopped

    //endregion Timers

    //region Observers

    @SuppressLint("CheckResult")
    private inline fun backgroundObserver() {
        var done = false
        Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .subscribeOn(Schedulers.computation())
                .subscribe(
                        object : Observer<Long> {

                            override fun onNext(it: Long) {
                                if (this@Task !in Caches.tasks) done = true
                                if (observingProperties[TIME]!!) observeTime()
                                if (observingProperties[DURATION]!!) observeDuration()
                                if (observingProperties[CHECKLIST]!!) observeChecklist()
                                if (observingProperties[DEADLINE]!!) observeDeadline()
                                if (observingProperties[BEFORE]!!) observeBefore()
                                if (observingProperties[SUB_TASKS]!!) observeSubTasks()
                            }

                            override fun onError(e: Throwable) {
                                throw e
                            }

                            override fun onComplete() {
                                logD("Observing ENDED for Task: $name $id because " +
                                        if (done) "not in cache" else "IMPOSSIBLE!")
                            }

                            override fun onSubscribe(d: Disposable) {
                                logD("Observing STARTED for Task: $name $id")
                            }
                        }
                )
    }

    private inline fun observingDone(property: Properties) {
        if (property !in observingProperties.keys)
            throw IllegalArgumentException("$property doesn't exist in observingProperties")
        observingProperties[property] = false
        update()
    }

    private inline fun observeTime() {
        when {
            this.time.isNotConstrained -> {
                makeNonFailableIfNoConstraints()
                if (this.state == TaskState.SLEEPING) this.state = TaskState.EXISTING
                observingDone(TIME)
            }
            this.time.value.isInThePast -> {
                if (this.state == TaskState.SLEEPING) this.state = TaskState.EXISTING
                if (this.time.isConstrained && this.time.isUnMet) {
                    this.time.isMet = MET
                }
                observingDone(TIME)
            }
        }
    }

    private inline fun observeDuration() {
        when {
            duration.isNotConstrained -> {
                makeNonFailableIfNoConstraints()
                observingDone(DURATION)
            }
            timer.stopped -> {
                observingDone(DURATION)
            }
            timer.duration >= duration.value -> {
                if (duration.isConstrained && duration.isUnMet) {
                    this.duration.isMet = MET
                }
                observingDone(DURATION)
            }
        }
    }

    private inline fun observeChecklist() {
        when {
            !this.checklist.isConstrained -> {
                makeNonFailableIfNoConstraints()
                observingDone(CHECKLIST)
            }
            this.checklist.value.getAllUncheckedItems().isEmpty() -> {
                if (this.checklist.isConstrained && this.checklist.isMet != MET) {
                    this.checklist.isMet = MET
                }
                observingDone(CHECKLIST)
            }
        }
    }

    private inline fun observeDeadline() {
        val deadlineWithGrace = this.deadline.value + GRACE_PERIOD
        when {
            !this.deadline.isConstrained -> {
                makeNonFailableIfNoConstraints()
                observingDone(DEADLINE)
            }
            now.isAfter(deadlineWithGrace) -> {
                if (canFail()) {
                    this.fail()
                    deadline.isMet = false
                }
                observingDone(DEADLINE)
            }
        }
    }

    private inline fun observeBefore() {
        val beforeTask = Caches.tasks[this.before.value]
        when {
            !Caches.tasks.contains(beforeTask) -> {
                throw ObserverException("Before Constraint checking failed!" +
                        " Before is null in database")
            }
            !this.before.isConstrained -> {
                makeNonFailableIfNoConstraints()
                observingDone(BEFORE)
            }
            beforeTask.state == TaskState.KILLED -> {
                this.before.isMet = true
                observingDone(BEFORE)
            }
            beforeTask.state == TaskState.FAILED -> {
                this.before.isMet = false
                if (canFail()) fail()
                observingDone(BEFORE)
            }

        }
    }

    private inline fun observeSubTasks() {
        when {
            !Caches.tasks.containsAll(this.subTasks.value.tasks) -> {
                throw ObserverException("SubTasks Constraint checking failed!" +
                        " Some SubTask is null in database")
            }
            !this.subTasks.isConstrained -> {
                makeNonFailableIfNoConstraints()
                observingDone(SUB_TASKS)
            }
            this.subTasks.value.tasks.any { it.state == TaskState.FAILED } -> {
                subTasks.isMet = false
                if (canFail()) fail()
                observingDone(SUB_TASKS)
            }
            this.subTasks.value.tasks
                    .all { it.state == TaskState.KILLED } -> {
                subTasks.isMet = true
                observingDone(SUB_TASKS)
            }

        }
    }

    /*
     * Pick one implementation to avoid memory leaks, either we have an in memory database, in which case we check if
     * this task is in it, if it's not then it implies this task is no longer used meaning lets kill all its
     * observers or we just call a finalizing method when we know this task will no longer be used, I don't think
     * both can work together but I could be wrong, the first one though may be very memory expensive, or not, we
     * have to really test this per platform, it might actually not be memory expensive, or at least its a necessary
     * expense because we can use the in memory database to access tasks very quickly, thus making the in memory
     * database a sort of buffer between the persistent database and the live runtime
     */

    // Can't restart them (not that I know of). dangerous!
    // Lifecycle will not happen automatically if there are no observers checking, even when it should
/*    private fun endObservers() {
        val message = when {
            activeObservers.isEmpty() -> "none"
            else -> activeObservers.toString()
        }
        val message0 = activeObservers.toString()

        composite.clear()
        activeObservers.clear()

        debug("$id has ended its observers: $message0")
    }*/

    //endregion Observers

    //region Overriden

    override fun notDefault(): Boolean {
        return name != "" || id != 0L
    }

    override fun initialize() {
        backgroundObserver()
    }

    /**
     * Returns the hash code of this Task, this is the hash code of this Task's equalityBundle, see [equalityBundle]
     *
     * @see java.util.AbstractMap.hashCode
     * @see Any.hashCode
     * @return the hash code of this Task
     */
    override fun hashCode() = equalityBundle.hashCode()

    /**
     * Checks whether the given `other` is equal to this Task or not, if `other` is not a Task then returns false, then
     * determines that the Tasks are equal if and only if their bundles are equal [equalityBundle]
     *
     * @see Task.equalityBundle
     * @see Any.equals
     * @return true if `other` is a Task and its equalityBundle is equal to this Task's equalityBundle, false otherwise
     */
    override fun equals(other: Any?) =
            other is Task && other.equalityBundle == this.equalityBundle

    /**
     * Returns the String representation of this Task, depicted using Task Card syntax which appears as follows:
     * ```
     * "My Task"
     * ID: 123456789 isKillable: true isFailable: false state: EXISTING
     *     P:
     *         ...
     *     C:
     *         ...
     * ```
     *
     * The Properties and Constraints are represented using their toString function. [Property.toString]
     *
     * @see Any.toString
     * @return the String representation of this Task
     */
    override fun toString(): String {
        //return Gson().toJson(this) // this is probably way better!
        val result = StringBuilder("$name\n")
        result.append("ID: $id isKillable: $isKillable isFailable: $isFailable state: $state\n")

        if (allShowingProperties.isNotEmpty()) {
            result.append("\tP:\n")
            allShowingProperties.filter { !it.isConstrained }.forEach { result.append("\t\t$it\n") }
        }

        if (allShowingConstraints.isNotEmpty()) {
            result.append("\tC:\n")
            allShowingConstraints.forEach { result.append("\t\t$it\n") }
        }

        return result.toString()
    }

    //endregion Overriden

    //region Template Task

    fun toTemplate(name: String = this.name) = Template(name, this)

    companion object {
        fun fromTemplate(template: Template, name: String) = Template.fromTemplate(template, name)

        fun taskTemplatesAreSubset(superTask: Task, subTask: Task) =
                Template.templatesAreSubset(superTask.toTemplate(), subTask.toTemplate())
    }

    //endregion Template Task
}